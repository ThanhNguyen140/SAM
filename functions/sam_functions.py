from skimage.transform import resize
import os
from multiprocessing import pool
import pickle
import numpy as np
import nibabel as nib
import matplotlib.pyplot as plt
import cv2
import torch
import math
import random
from segment_anything import SamPredictor, sam_model_registry, SamAutomaticMaskGenerator
from thanh.preprocess import preprocess_image


def show_mask(mask, ax, random_color=False):
    if random_color:
        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
    else:
        color = np.array([30 / 255, 144 / 255, 255 / 255, 0.6])
    h, w = mask.shape[-2:]
    mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)
    ax.imshow(mask_image)


def show_points(coords, labels, ax, marker_size=10):
    pos_points = coords[labels == 1]
    neg_points = coords[labels == 0]
    ax.scatter(
        pos_points[:, 0], pos_points[:, 1], color="green", marker="o", s=marker_size
    )
    ax.scatter(
        neg_points[:, 0], neg_points[:, 1], color="red", marker="o", s=marker_size
    )


def sample_from_class(ground_truth, target_class: int, n_points: int):
    """
    Generates a list of randomly sampled points from one class of the ground_truth and returns
    them in a readable form for SAM.

    Arguments:
    ground_truth: 2D-array, assigned labels of the original image
    target_class: integer, class to which the sampled points should belong
    n_points: number of points that should be returned

    Returns:
    list of n points belonging to the target_class
    """
    rows, cols = np.where(ground_truth == target_class)
    points = [[col, row] for row, col in zip(rows, cols)]
    sampled_points = np.array(random.sample(points, n_points))
    return sampled_points


def get_masks(prompts, predictor):
    """This function returns the models masks for a given list of prompts.

    Args:
        prompts (list): List of lists of sampled points from ground truth
        predictor (SAMPredictor): Predictor that has alsready a set image

    Returns:
        np.array: 3D array with the masks (one for each class)
    """
    masks = []
    for label, prompt in enumerate(prompts):
        input_labels = np.array([1] * len(prompt))  # label all points as forground
        mask, score, logit = predictor.predict(
            point_coords=prompt,
            point_labels=input_labels,
            multimask_output=False,
        )
        masks.append(mask)
    return masks


def get_logits(prompts, predictor):
    """This function returns the models logits of the masks.

    Args:
        prompts (list): List of lists of input points
        predictor (SAMPredictor): Predictor that has already a set image

    Returns:
        np.array: 3D array with the logits from the models output of three given prompts
        (one for each class)
    """

    masks = []
    for label, prompt in enumerate(prompts):
        input_labels = np.array([1] * len(prompt))  # label all points as forground
        mask, score, logit = predictor.predict(
            point_coords=prompt,
            point_labels=input_labels,
            multimask_output=False,
            return_logits=True,
        )  # create mask with highest internal score
        masks.append(mask)
    return masks


def multiclass_prob(binary_logits):
    """Get probabilities for multiclass classification.

    Args:
        binary_logits (np.array): Logits generated by SAM for each
        foreground class

    Returns:
        np.array: Multiclass probabilities for different objects and background
    """
    probabilities = []
    for classnr, logit in enumerate(binary_logits):
        # Apply sigmoid function to get probabilities
        probabilities.append(1 / (1 + np.exp(-logit[0])))

    multiclass_prob = np.zeros(
        probabilities[0].shape + (len(binary_logits) + 1,)
    )  # initialize multiclass probabilities
    bin_probs = np.stack(
        probabilities, axis=-1
    )  # combine binary probabilities for foreground classes
    sum_probs = np.sum(bin_probs, axis=-1)
    prob_background = 1 - sum_probs

    mask = sum_probs > 1  # check where to apply our heuristic
    bin_probs[mask] /= sum_probs[mask, None]
    prob_background[mask] = 0

    multiclass_prob[..., : len(binary_logits)] = bin_probs
    multiclass_prob[
        ..., -1
    ] = prob_background  # Use the last channel for prob_background

    return multiclass_prob
